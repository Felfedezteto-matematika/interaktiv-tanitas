<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Középpontos tükrözés</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
    <style>
        .point {
            cursor: pointer;
        }

        /* ÚJ: Ezzel megakadályozzuk, hogy a kurzor megváltozzon a feliratok felett */
        svg text {
            pointer-events: none;
        }
    </style>
</head>
<body class="font-sans flex flex-col items-center justify-center min-h-screen bg-slate-100 text-slate-800 p-4">

<div class="container w-full max-w-xl bg-white rounded-xl shadow-lg p-6 flex flex-col items-center">
    <h1 class="text-2xl font-semibold text-slate-900 mb-4 text-center">Középpontos tükrözés</h1>

    <div class="bg-slate-50 p-4 rounded-lg shadow-inner mb-6 text-slate-700 text-center">
        <p>A feladat, hogy minél pontosabban meghatárold a P pont középpontosan tükrözött képét. Segítségül megadtunk egy háromszöget (feketével), és ennek a tükörképét (szürkével). Cél, hogy a tippjeid eltérésének átlaga kisebb legyen 25 egységnél.</p>
    </div>

    <svg id="svgCanvas" class="w-full h-96 border border-slate-300 rounded-lg bg-slate-50 shadow-inner" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet"></svg>

    <button id="mainActionButton" class="mt-6 py-3 px-6 text-lg font-semibold rounded-lg shadow-md transition-all duration-200 ease-in-out bg-slate-300 text-slate-800 hover:bg-slate-400 disabled:opacity-50 disabled:cursor-not-allowed">Következő feladvány</button>

    <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-4 w-full">
        <div class="flex flex-col items-start">
            <div class="text-lg font-semibold text-slate-800 text-left mb-2">Tippek eltérései:</div>
            <div id="deviationBoxesWrapper" class="flex flex-wrap justify-center gap-2">
                <div id="deviationBox0" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-slate-100 border border-slate-300 rounded-md text-slate-600">--</div>
                <div id="deviationBox1" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-slate-100 border border-slate-300 rounded-md text-slate-600">--</div>
                <div id="deviationBox2" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-slate-100 border border-slate-300 rounded-md text-slate-600">--</div>
                <div id="deviationBox3" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-slate-100 border border-slate-300 rounded-md text-slate-600">--</div>
                <div id="deviationBox4" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-slate-100 border border-slate-300 rounded-md text-slate-600">--</div>
            </div>
        </div>
        <div class="flex flex-col items-center">
            <div class="text-lg font-semibold text-slate-800 text-center mb-2">Átlag:</div>
            <div id="averageDeviationBox" class="w-16 h-10 flex items-center justify-center text-sm font-bold bg-blue-100 border border-blue-300 rounded-md text-blue-800">--</div>
        </div>
    </div>

    <div id="gameStatus" class="mt-6 text-xl font-medium text-slate-800 text-center"></div>

</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const svgCanvas = document.getElementById('svgCanvas');
        const gameStatusEl = document.getElementById('gameStatus');
        const mainActionButton = document.getElementById('mainActionButton');
        const averageDeviationBox = document.getElementById('averageDeviationBox');
        const deviationBoxesWrapper = document.getElementById('deviationBoxesWrapper');
        
        // --- Játék állapotának változói ---
        let state = {
            currentPuzzle: 1,
            totalPuzzles: 5,
            allDistances: [],
            isGuessMade: false,
            puzzleData: {}
        };

        // --- Segédfüggvények ---

        // Új segédfüggvény a több attribútum beállításához
        function setAttributes(el, attrs) {
            for (const key in attrs) {
                el.setAttribute(key, attrs[key]);
            }
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function clearCanvas() {
            svgCanvas.innerHTML = '';
        }

        // --- Pont és háromszög generálása és ellenőrzése ---
        function generateValidPoints() {
            const minCoord = 50, maxCoord = 350;
            const buffer = 30;
            const minAngleRad = 15 * Math.PI / 180;

            const getRandomPoint = () => ({
                x: getRandomInt(minCoord, maxCoord),
                y: getRandomInt(minCoord, maxCoord)
            });

            const getDistance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

            const areAnglesValid = (p1, p2, p3) => {
                const a = getDistance(p2, p3);
                const b = getDistance(p1, p3);
                const c = getDistance(p1, p2);

                if (a === 0 || b === 0 || c === 0) return false;

                const angleA = Math.acos((b * b + c * c - a * a) / (2 * b * c));
                const angleB = Math.acos((a * a + c * c - b * b) / (2 * a * c));
                const angleC = Math.acos((a * a + b * b - c * c) / (2 * a * b));

                return angleA >= minAngleRad && angleB >= minAngleRad && angleC >= minAngleRad;
            };

            const isOutOfBounds = (points) => {
                return points.some(p => p.x < buffer || p.x > 400 - buffer || p.y < buffer || p.y > 400 - buffer);
            };

            while (true) {
                const centerO = getRandomPoint();
                const pointP = getRandomPoint();
                const pointsABC = [getRandomPoint(), getRandomPoint(), getRandomPoint()];

                if (!areAnglesValid(pointsABC[0], pointsABC[1], pointsABC[2])) continue;

                const pointP_prime = {
                    x: 2 * centerO.x - pointP.x,
                    y: 2 * centerO.y - pointP.y
                };

                const pointsABC_prime = pointsABC.map(p => ({
                    x: 2 * centerO.x - p.x,
                    y: 2 * centerO.y - p.y
                }));

                const allPoints = [centerO, pointP, pointP_prime, ...pointsABC, ...pointsABC_prime];
                
                if (!isOutOfBounds(allPoints)) {
                    return {
                        O: centerO,
                        P: pointP,
                        P_prime: pointP_prime,
                        ABC: pointsABC,
                        ABC_prime: pointsABC_prime
                    };
                }
            }
        }

        function draw100UnitsScale() {
            const endX = 380;
            const startX = endX - 100;
            const startY = 380;

            // Vonal
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            setAttributes(line, {
                x1: startX,
                y1: startY,
                x2: endX,
                y2: startY,
                stroke: "#475569",
                "stroke-width": "2"
            });
            svgCanvas.appendChild(line);

            // Jelölők
            const tick1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            setAttributes(tick1, {
                x1: startX,
                y1: startY - 5,
                x2: startX,
                y2: startY + 5,
                stroke: "#475569",
                "stroke-width": "2"
            });
            svgCanvas.appendChild(tick1);

            const tick2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            setAttributes(tick2, {
                x1: endX,
                y1: startY - 5,
                x2: endX,
                y2: startY + 5,
                stroke: "#475569",
                "stroke-width": "2"
            });
            svgCanvas.appendChild(tick2);

            // Szöveg
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            setAttributes(text, {
                x: startX + 50,
                y: startY - 10,
                "text-anchor": "middle",
                "font-size": "12",
                fill: "#475569"
            });
            text.textContent = "100 egység";
            svgCanvas.appendChild(text);
        }

        // --- Kirajzoló függvények ---
        function drawPuzzle() {
            clearCanvas();
            state.isGuessMade = false;
            
            state.puzzleData = generateValidPoints();
            const { P, ABC, ABC_prime } = state.puzzleData;
            
            draw100UnitsScale();

            // Kezdő háromszög
            const pointsString = ABC.map(p => `${p.x},${p.y}`).join(' ');
            const triangle = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            setAttributes(triangle, {
                points: pointsString,
                fill: "none",
                stroke: "#000000",
                "stroke-width": "2"
            });
            svgCanvas.appendChild(triangle);

            // Tükörkép háromszög
            const primePointsString = ABC_prime.map(p => `${p.x},${p.y}`).join(' ');
            const reflectedTriangle = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            setAttributes(reflectedTriangle, {
                points: primePointsString,
                fill: "none",
                stroke: "#808080",
                "stroke-width": "2",
                "stroke-dasharray": "5,5"
            });
            svgCanvas.appendChild(reflectedTriangle);
            
            // P pont és felirat
            const pointP = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            setAttributes(pointP, {
                cx: P.x,
                cy: P.y,
                r: 4,
                fill: "#1D4ED8"
            });
            svgCanvas.appendChild(pointP);
            
            const textP = document.createElementNS("http://www.w3.org/2000/svg", "text");
            setAttributes(textP, {
                x: P.x + 5,
                y: P.y + 5,
                fill: "#1D4ED8",
                "font-size": "12"
            });
            textP.textContent = "P";
            svgCanvas.appendChild(textP);

            // A, B, C és A', B', C' feliratok a szögfelezőkön kifelé
            const labels = ["A", "B", "C"];
            [ABC, ABC_prime].forEach((trianglePoints, triIndex) => {
                const isPrime = triIndex === 1;
                const strokeColor = isPrime ? "#808080" : "#000000";

                trianglePoints.forEach((p, i) => {
                    // Számítsuk ki a háromszög súlypontját (centroid)
                    const centroid = {
                        x: (trianglePoints[0].x + trianglePoints[1].x + trianglePoints[2].x) / 3,
                        y: (trianglePoints[0].y + trianglePoints[1].y + trianglePoints[2].y) / 3
                    };
                    
                    const dx = p.x - centroid.x;
                    const dy = p.y - centroid.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // A felirat helye a súlyponttól kifelé tolva
                    const labelOffset = 20; 
                    const labelX = p.x + (dx / dist) * labelOffset;
                    const labelY = p.y + (dy / dist) * labelOffset;

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    setAttributes(text, {
                        x: labelX,
                        y: labelY,
                        fill: strokeColor,
                        "font-size": "12",
                        "text-anchor": "middle",
                        "dominant-baseline": "middle"
                    });
                    text.textContent = labels[i] + (isPrime ? "'" : "");
                    svgCanvas.appendChild(text);
                });
            });
            
            gameStatusEl.textContent = `${state.currentPuzzle} / ${state.totalPuzzles}: Hol van a P pont tükörképe? Kattints a válaszhoz!`;
            mainActionButton.disabled = true;
            averageDeviationBox.textContent = '--';
            for (let i = 0; i < state.totalPuzzles; i++) {
                const box = document.getElementById(`deviationBox${i}`);
                box.textContent = '--';
            }
        }

        function showSolutionAndAnimate(onComplete) {
            const { P, P_prime, O } = state.puzzleData;
            
            // Hozzáadjuk a megoldást és a tengelyt
            const solutionPoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            setAttributes(solutionPoint, {
                cx: P_prime.x,
                cy: P_prime.y,
                r: 5,
                fill: "#22C55E"
            });
            svgCanvas.appendChild(solutionPoint);

            const centerPointO = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            setAttributes(centerPointO, {
                cx: O.x,
                cy: O.y,
                r: 5,
                fill: "#EF4444"
            });
            svgCanvas.appendChild(centerPointO);

            const centerTextO = document.createElementNS("http://www.w3.org/2000/svg", "text");
            setAttributes(centerTextO, {
                x: O.x + 10,
                y: O.y,
                fill: "#EF4444",
                "font-size": "12"
            });
            centerTextO.textContent = "O";
            svgCanvas.appendChild(centerTextO);
            
            const linePP = document.createElementNS("http://www.w3.org/2000/svg", "line");
            setAttributes(linePP, {
                x1: P.x,
                y1: P.y,
                x2: P_prime.x,
                y2: P_prime.y,
                stroke: "#475569",
                "stroke-dasharray": "2,2"
            });
            svgCanvas.appendChild(linePP);
            
            // Animáció
            const startPointsString = state.puzzleData.ABC.map(p => `${p.x},${p.y}`).join(' ');
            const endPointsString = state.puzzleData.ABC_prime.map(p => `${p.x},${p.y}`).join(' ');
            const animTriangle = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            setAttributes(animTriangle, {
                points: startPointsString,
                fill: "none",
                stroke: "#000000",
                "stroke-width": "2"
            });
            svgCanvas.appendChild(animTriangle);

            const animPointP = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            setAttributes(animPointP, {
                cx: P.x,
                cy: P.y,
                r: 4,
                fill: "#1D4ED8"
            });
            svgCanvas.appendChild(animPointP);

            const duration = 2500;
            const delay = 500;

            setTimeout(() => {
                const startTime = performance.now();
                function animate(currentTime) {
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);

                    const startPoints = startPointsString.split(' ').map(p => p.split(',').map(Number));
                    const endPoints = endPointsString.split(' ').map(p => p.split(',').map(Number));
                    const currentPoints = startPoints.map((start, i) => {
                        const end = endPoints[i];
                        const x = start[0] + (end[0] - start[0]) * progress;
                        const y = start[1] + (end[1] - start[1]) * progress;
                        return `${x},${y}`;
                    }).join(' ');
                    animTriangle.setAttribute('points', currentPoints);
                    
                    const currentPx = P.x + (P_prime.x - P.x) * progress;
                    const currentPy = P.y + (P_prime.y - P.y) * progress;
                    animPointP.setAttribute("cx", currentPx);
                    animPointP.setAttribute("cy", currentPy);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (onComplete) {
                            onComplete();
                        }
                    }
                }
                requestAnimationFrame(animate);
            }, delay);
        }

        // --- Kijelzők frissítése ---
        function updateDisplays() {
            const isGameEnd = state.currentPuzzle === state.totalPuzzles && state.isGuessMade;

            if (isGameEnd) {
                gameStatusEl.textContent = "Vége a játéknak!";
                mainActionButton.textContent = "Új játék";
                mainActionButton.classList.remove('bg-slate-300', 'hover:bg-slate-400');
                mainActionButton.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white');
            } else {
                gameStatusEl.textContent = `${state.currentPuzzle} / ${state.totalPuzzles} forduló`;
                mainActionButton.textContent = "Következő feladvány";
                mainActionButton.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
                mainActionButton.classList.add('bg-slate-300', 'hover:bg-slate-400');
            }
            
            if (state.allDistances.length > 0) {
                const totalDistance = state.allDistances.reduce((sum, current) => sum + current, 0);
                const averageDistance = totalDistance / state.allDistances.length;
                averageDeviationBox.textContent = averageDistance.toFixed(1);

                // ÚJ: Háttérszín ellenőrzése és módosítása az utolsó feladvány után
                if (isGameEnd) {
                    if (averageDistance < 25) {
                        // Siker esetén a háttér zöldre vált
                        averageDeviationBox.classList.remove('bg-blue-100', 'border-blue-300', 'text-blue-800', 'bg-red-200', 'border-red-400', 'text-red-800');
                        averageDeviationBox.classList.add('bg-green-200', 'border-green-400', 'text-green-800');
                        gameStatusEl.textContent += " Gratulálunk, pontosan tippeltél! 👍";
                    }
                } else {
                    // Játék közben visszaállítjuk a kék színt, ha szükséges
                    averageDeviationBox.classList.remove('bg-green-200', 'border-green-400', 'text-green-800', 'bg-red-200', 'border-red-400', 'text-red-800');
                    averageDeviationBox.classList.add('bg-blue-100', 'border-blue-300', 'text-blue-800');
                }
            } else {
                averageDeviationBox.textContent = `--`;
                // Játék kezdetén visszaállítjuk a kék színt
                averageDeviationBox.classList.remove('bg-green-200', 'border-green-400', 'text-green-800', 'bg-red-200', 'border-red-400', 'text-red-800');
                averageDeviationBox.classList.add('bg-blue-100', 'border-blue-300', 'text-blue-800');
            }

            for (let i = 0; i < state.totalPuzzles; i++) {
                const box = document.getElementById(`deviationBox${i}`);
                if (i < state.allDistances.length) {
                    box.textContent = state.allDistances[i].toFixed(1);
                } else {
                    box.textContent = `--`;
                }
            }
        }

        // --- Eseménykezelők ---
        svgCanvas.addEventListener('click', (event) => {
            if (state.isGuessMade) {
                return;
            }
            state.isGuessMade = true;

            const pt = svgCanvas.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            const svgPoint = pt.matrixTransform(svgCanvas.getScreenCTM().inverse());
            const click_x = svgPoint.x;
            const click_y = svgPoint.y;

            const { P_prime } = state.puzzleData;

            // Tipped pontjának megjelenítése
            const guessedCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            setAttributes(guessedCircle, {
                cx: click_x,
                cy: click_y,
                r: 6,
                fill: "#3B82F6"
            });
            guessedCircle.classList.add("guessed-point");
            svgCanvas.appendChild(guessedCircle);

            const deviationLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            setAttributes(deviationLine, {
                x1: click_x,
                y1: click_y,
                x2: P_prime.x,
                y2: P_prime.y,
                stroke: "#475569",
                "stroke-dasharray": "2,2"
            });
            svgCanvas.appendChild(deviationLine);

            const distance = Math.sqrt(Math.pow(click_x - P_prime.x, 2) + Math.pow(click_y - P_prime.y, 2));
            state.allDistances.push(distance);

            showSolutionAndAnimate(() => {
                updateDisplays();
                mainActionButton.disabled = false;
            });
        });

        mainActionButton.addEventListener('click', () => {
            if (state.currentPuzzle < state.totalPuzzles) {
                state.currentPuzzle++;
                drawPuzzle();
            } else {
                // Játék vége - újraindítás
                state.currentPuzzle = 1;
                state.allDistances = [];
                drawPuzzle();
            }
            updateDisplays();
        });

        // --- Inicializálás ---
        drawPuzzle();
        updateDisplays();
    });
</script>

</body>
</html>
