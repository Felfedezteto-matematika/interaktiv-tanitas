<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duplán tükrözés</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #ffffff;
            --fg: #1a1a1a;
            --card-bg: #f9fafb;
            --border: #e0e0e0;
            --green: #22c55e;
            --green-dark: #16a34a;
            --blue: #3b82f6;
            --red: #ef4444;
            --text-muted: #757575;
            --shadow: 0 2px 4px rgba(0,0,0,0.05);
            --transition: all 0.2s ease-in-out;
            --yellow: #facc15;
        }

        html, body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            transition: background var(--transition), color var(--transition);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 24px 16px;
        }

        .container {
            max-width: 980px;
            width: 100%;
        }

        h1 {
            font-weight: 700;
            font-size: 2rem;
            margin: 0 0 4px 0;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .card {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            background: var(--card-bg);
            box-shadow: var(--shadow);
            transition: background var(--transition), box-shadow var(--transition), border-color var(--transition);
        }

        .task-title {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 20px;
        }

        .canvas-wrap {
            position: relative;
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            background: #fff;
            transition: background var(--transition);
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            max-width: 940px;
            height: 400px;
            cursor: crosshair;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-top: 20px;
        }

        .status {
            margin-top: 12px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .status.ok {
            color: var(--green-dark);
        }

        .status.err {
            color: var(--red);
        }
        
        .status.info {
            color: var(--blue);
        }

        .task-toggle {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .task-toggle button {
            padding: 6px 12px;
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .task-toggle button.active {
            background: var(--green);
            color: #fff;
            border-color: var(--green);
        }
        
        .task-toggle button.solved {
            background: var(--green);
            color: #fff;
            border-color: var(--green);
        }
        
        .task-toggle button:hover {
            border-color: var(--text-muted);
            background-color: #f5f5f5;
        }
        
        .task-toggle button.active:hover,
        .task-toggle button.solved:hover {
            background: var(--green-dark);
        }

        button.primary {
            background: var(--green);
            color: #fff;
            border: 1px solid var(--green);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }

        button.primary:hover {
            background: var(--green-dark);
            border-color: var(--green-dark);
        }

        button.secondary {
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
        }
        
        button.secondary.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
        }
        
        button.secondary:hover {
            border-color: var(--text-muted);
            background-color: #f5f5f5;
        }
        
        button.secondary.disabled:hover {
            border-color: var(--border);
            background-color: var(--bg);
        }

        .btn-container {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .full-width {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Duplán tükrözés</h1>
        <div class="subtitle">Kattints a vászonra, hogy elhelyezd a P'' pontot.</div>

        <div class="card">
            <h2 id="task-title" class="task-title"></h2>
            
            <div class="canvas-wrap">
                <canvas id="gameCanvas" width="940" height="400"></canvas>
            </div>

            <div class="controls">
                <div id="action-buttons" class="btn-container">
                    <button id="prevBtn" class="secondary">Előző</button>
                    <button id="nextBtn" class="secondary">Következő</button>
                    <button id="retryBtn" class="secondary">Újra próbálom!</button>
                </div>
                <div class="task-toggle" id="round-navigation"></div>
            </div>

            <div id="feedback" class="status info">Kattints a vászonra, hogy elhelyezd a P'' pontot.</div>
            <div id="endMessage" style="display: none;" class="end-message">
                <h2 style="margin-top: 0;">Gratulálunk, az összes feladatot sikeresen megoldottad!</h2>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const feedbackEl = document.getElementById('feedback');
            const roundNavigationEl = document.getElementById('round-navigation');
            const taskTitleEl = document.getElementById('task-title');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const retryBtn = document.getElementById('retryBtn');
            const endMessageEl = document.getElementById('endMessage');

            // --- Game State Variables ---
            const tolerance = 30;
            const totalRounds = 6;
            const margin = 50;
            let currentRound = 1;
            let correctPoint;
            let pPoint;
            let redLine, blueLine, greenLine;
            let isRoundFinished = false;
            let userGuessPoint = null;
            let solvedRounds = new Set();
            
            // --- Helper Functions ---
            function generateRandomPoint() {
                return {
                    x: Math.random() * (canvas.width - 2 * margin) + margin,
                    y: Math.random() * (canvas.height - 2 * margin) + margin
                };
            }
            
            function isPointInBounds(point) {
                return point.x > margin && point.x < canvas.width - margin &&
                       point.y > margin && point.y < canvas.height - margin;
            }

            function generateParallelLines() {
                const slope = Math.tan(Math.random() * Math.PI);
                const midHeight = canvas.height / 2;
                const minInterceptOffset = -50;
                const maxInterceptOffset = 50;
                const interceptMid = midHeight + Math.random() * (maxInterceptOffset - minInterceptOffset) + minInterceptOffset;
                const separation = Math.random() * 80 + 40;
                
                return [
                    { m: slope, c: interceptMid - separation / 2 },
                    { m: slope, c: interceptMid + separation / 2 }
                ];
            }

            function generateIntersectingLines(centerPoint) {
                const angle1 = Math.random() * Math.PI;
                const angle2 = angle1 + Math.random() * (Math.PI / 2) + Math.PI / 6; 
                return [
                    { m: Math.tan(angle1), c: centerPoint.y - Math.tan(angle1) * centerPoint.x },
                    { m: Math.tan(angle2), c: centerPoint.y - Math.tan(angle2) * centerPoint.x }
                ];
            }
            
            function generateThreeIntersectingLines(centerPoint) {
                let angle1, angle2, angle3;
                let isValid = false;
                const minAngleRad = Math.PI / 9; // 20 degrees
                
                while (!isValid) {
                    angle1 = Math.random() * Math.PI;
                    angle2 = angle1 + Math.random() * (Math.PI / 2) + Math.PI / 6;
                    angle3 = angle2 + Math.random() * (Math.PI / 2) + Math.PI / 6;
                    
                    const a1 = angle1 % (2 * Math.PI);
                    const a2 = angle2 % (2 * Math.PI);
                    const a3 = angle3 % (2 * Math.PI);
                    
                    let angles = [a1, a2, a3].sort((a,b) => a-b);
                    
                    if (angles[1] - angles[0] > minAngleRad &&
                        angles[2] - angles[1] > minAngleRad &&
                        (angles[0] + 2 * Math.PI) - angles[2] > minAngleRad) {
                        isValid = true;
                    }
                }

                return [
                    { m: Math.tan(angle1), c: centerPoint.y - Math.tan(angle1) * centerPoint.x },
                    { m: Math.tan(angle2), c: centerPoint.y - Math.tan(angle2) * centerPoint.x },
                    { m: Math.tan(angle3), c: centerPoint.y - Math.tan(angle3) * centerPoint.x }
                ];
            }

            function isPointBetweenLines(point, line1, line2) {
                const signedDistance1 = (line1.m * point.x - point.y + line1.c) / Math.sqrt(line1.m * line1.m + 1);
                const signedDistance2 = (line2.m * point.x - point.y + line2.c) / Math.sqrt(line2.m * line2.m + 1);
                return signedDistance1 * signedDistance2 < 0;
            }

            function reflectPoint(point, line) {
                const a = line.m;
                const b = -1;
                const c = line.c;
                const denominator = a * a + b * b;
                if (denominator === 0) return { x: point.x, y: point.y };
                const numerator = a * point.x + b * point.y + c;
                const reflectedX = point.x - 2 * a * numerator / denominator;
                const reflectedY = point.y - 2 * b * numerator / denominator;
                return { x: reflectedX, y: reflectedY };
            }
            
            function getDistance(p1, p2) {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function getDistanceToLine(point, line) {
                return Math.abs(line.m * point.x - point.y + line.c) / Math.sqrt(line.m * line.m + 1);
            }

            function drawPoint(point, label, color = '#111', radius = 6) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '16px Inter';
                ctx.fillText(label, point.x + 8, point.y - 8);
            }
            
            function drawLine(line, color = '#333') {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                const x1 = 0;
                const y1 = line.m * x1 + line.c;
                const x2 = canvas.width;
                const y2 = line.m * x2 + line.c;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (redLine) drawLine(redLine, 'red');
                if (blueLine) drawLine(blueLine, 'blue');
                if (greenLine) drawLine(greenLine, 'green');
                if (pPoint) drawPoint(pPoint, 'P');
                if (userGuessPoint) {
                    drawPoint(userGuessPoint, "P'' (Te)", 'blue');
                }
                if (isRoundFinished) {
                    drawPoint(correctPoint, "P'' (Helyes)", 'green');
                }
            }

            function setupNewRound(round) {
                currentRound = round;
                
                // Reset state
                userGuessPoint = null;
                isRoundFinished = false;
                redLine = null;
                blueLine = null;
                greenLine = null;
                pPoint = null;
                correctPoint = null;
                endMessageEl.style.display = 'none';

                let pPrime, pDoublePrime;
                let isSetupValid = false;
                
                while (!isSetupValid) {
                    isSetupValid = true;
                    if (currentRound <= 4) {
                        let lines = generateParallelLines();
                        redLine = lines[0];
                        blueLine = lines[1];
                        const separation = getDistanceToLine({x: 0, y: redLine.c}, blueLine);
                        
                        switch(currentRound) {
                            case 1:
                                pPoint = generateRandomPoint();
                                pPrime = reflectPoint(pPoint, redLine);
                                correctPoint = reflectPoint(pPrime, blueLine);
                                if (isPointBetweenLines(pPoint, redLine, blueLine) || getDistanceToLine(pPoint, redLine) > separation || !isPointInBounds(pPrime) || !isPointInBounds(correctPoint)) {
                                     isSetupValid = false;
                                     continue;
                                }
                                break;
                            case 2:
                                pPoint = generateRandomPoint();
                                pPrime = reflectPoint(pPoint, redLine);
                                correctPoint = reflectPoint(pPrime, blueLine);
                                if (isPointBetweenLines(pPoint, redLine, blueLine) || getDistanceToLine(pPoint, redLine) < separation || !isPointInBounds(pPrime) || !isPointInBounds(correctPoint)) {
                                     isSetupValid = false;
                                     continue;
                                }
                                break;
                            case 3:
                                pPoint = generateRandomPoint();
                                pPrime = reflectPoint(pPoint, redLine);
                                correctPoint = reflectPoint(pPrime, blueLine);
                                if (!isPointBetweenLines(pPoint, redLine, blueLine) || !isPointInBounds(pPrime) || !isPointInBounds(correctPoint)) {
                                    isSetupValid = false;
                                    continue;
                                }
                                break;
                            case 4:
                                pPoint = generateRandomPoint();
                                pPrime = reflectPoint(pPoint, redLine);
                                correctPoint = reflectPoint(pPrime, blueLine);
                                if (isPointBetweenLines(pPoint, redLine, blueLine) || getDistanceToLine(pPoint, blueLine) > getDistanceToLine(pPoint, redLine) || getDistanceToLine(pPoint, blueLine) < 20 || !isPointInBounds(pPrime) || !isPointInBounds(correctPoint)) {
                                     isSetupValid = false;
                                     continue;
                                }
                                break;
                        }

                    } else if (currentRound === 5) {
                        let center = generateRandomPoint(canvas.width / 4);
                        let lines = generateIntersectingLines(center);
                        redLine = lines[0];
                        blueLine = lines[1];
                        pPoint = generateRandomPoint(100);
                        
                        pPrime = reflectPoint(pPoint, redLine);
                        correctPoint = reflectPoint(pPrime, blueLine);
                        
                        if (Math.abs(getDistanceToLine(pPoint, redLine)) < 20 || Math.abs(getDistanceToLine(pPoint, blueLine)) < 20 || !isPointInBounds(pPrime) || !isPointInBounds(correctPoint) || isPointBetweenLines(pPoint, redLine, blueLine)) {
                            isSetupValid = false;
                            continue;
                        }
                    } else if (currentRound === 6) {
                        let center = generateRandomPoint(canvas.width / 4);
                        let lines = generateThreeIntersectingLines(center);
                        redLine = lines[0];
                        blueLine = lines[1];
                        greenLine = lines[2];
                        pPoint = generateRandomPoint(100);

                        pPrime = reflectPoint(pPoint, redLine);
                        pDoublePrime = reflectPoint(pPrime, blueLine);
                        correctPoint = reflectPoint(pDoublePrime, greenLine);

                        if (Math.abs(getDistanceToLine(pPoint, redLine)) < 20 || Math.abs(getDistanceToLine(pPoint, blueLine)) < 20 || Math.abs(getDistanceToLine(pPoint, greenLine)) < 20 || !isPointInBounds(pPrime) || !isPointInBounds(pDoublePrime) || !isPointInBounds(correctPoint) || isPointBetweenLines(pPoint, redLine, blueLine) || !isPointBetweenLines(pPrime, redLine, blueLine) || isPointBetweenLines(pDoublePrime, blueLine, greenLine) ) {
                            isSetupValid = false;
                            continue;
                        }
                    }

                    if (correctPoint && (!isPointInBounds(correctPoint) || !isPointInBounds(pPoint))) {
                        isSetupValid = false;
                    }
                }

                updateTaskTitle();
                updateRoundToggle();
                updateButtonState();
                redrawCanvas();
                
                feedbackEl.textContent = 'Kattints a vászonra, hogy elhelyezd a P\'\' pontot.';
                feedbackEl.classList.add('info');
                feedbackEl.classList.remove('ok', 'err');
                
                canvas.style.cursor = 'crosshair';
            }

            function handleGuess(event) {
                if (isRoundFinished) return;

                const rect = canvas.getBoundingClientRect();
                userGuessPoint = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                checkAnswer();
            }

            function checkAnswer() {
                if (!userGuessPoint || isRoundFinished) return;
                
                const distance = getDistance(userGuessPoint, correctPoint);
                const distanceInUnits = (distance / 50).toFixed(2);
                
                isRoundFinished = true;
                redrawCanvas();

                if (distance <= tolerance) {
                    feedbackEl.textContent = `Helyes válasz! Pontos távolság: ${distanceInUnits} egység.`;
                    feedbackEl.classList.add('ok');
                    feedbackEl.classList.remove('info');
                    
                    solvedRounds.add(currentRound);
                    updateRoundToggle();
                    
                    if (solvedRounds.size === totalRounds) {
                        endMessageEl.style.display = 'block';
                    }

                } else {
                    feedbackEl.textContent = `A tipp és a helyes válasz közötti távolság: ${distanceInUnits} egység. Próbáld újra!`;
                    feedbackEl.classList.add('err');
                    feedbackEl.classList.remove('info');
                }
                updateButtonState();
                canvas.style.cursor = 'default';
            }
            
            function buildRoundToggle() {
                for (let i = 1; i <= totalRounds; i++) {
                    const btn = document.createElement('button');
                    btn.textContent = i;
                    btn.className = 'toggle-btn';
                    btn.addEventListener('click', () => {
                        if (currentRound !== i) {
                            setupNewRound(i);
                        }
                    });
                    roundNavigationEl.appendChild(btn);
                }
            }

            function updateButtonState() {
                if (currentRound === 1) {
                    prevBtn.classList.add('disabled');
                } else {
                    prevBtn.classList.remove('disabled');
                }

                if (currentRound === totalRounds) {
                    nextBtn.classList.add('disabled');
                } else {
                    nextBtn.classList.remove('disabled');
                }
            }

            function updateRoundToggle() {
                const buttons = roundNavigationEl.querySelectorAll('.toggle-btn');
                buttons.forEach((btn, index) => {
                    const roundNum = index + 1;
                    btn.classList.remove('active', 'solved');
                    if (roundNum === currentRound) {
                        btn.classList.add('active');
                    }
                    if (solvedRounds.has(roundNum)) {
                        btn.classList.add('solved');
                    }
                });
            }

            function updateTaskTitle() {
                const tasks = {
                    1: "A P pontot tükrözzük a piros, majd a kék egyenesre. Helyezd el az így kapott P'' pontot a síkon.",
                    2: "A P pontot tükrözzük a piros, majd a kék egyenesre. Helyezd el az így kapott P'' pontot a síkon.",
                    3: "A P pontot tükrözzük a piros, majd a kék egyenesre. Helyezd el az így kapott P'' pontot a síkon.",
                    4: "A P pontot tükrözzük a piros, majd a kék egyenesre. Helyezd el az így kapott P'' pontot a síkon.",
                    5: "A P pontot tükrözzük a piros, majd a kék egyenesre. Helyezd el az így kapott P'' pontot a síkon.",
                    6: "A P pontot tükrözzük a piros, majd a kék, majd a zöld egyenesre. Helyezd el az így kapott P''' pontot a síkon."
                };
                taskTitleEl.textContent = tasks[currentRound];
            }

            canvas.addEventListener('click', handleGuess);
            prevBtn.addEventListener('click', () => {
                if (currentRound > 1) {
                    setupNewRound(currentRound - 1);
                }
            });
            nextBtn.addEventListener('click', () => {
                if (currentRound < totalRounds) {
                    setupNewRound(currentRound + 1);
                }
            });
            retryBtn.addEventListener('click', () => {
                setupNewRound(currentRound);
            });
            
            buildRoundToggle();
            setupNewRound(1);
        };
    </script>
</body>
</html>
